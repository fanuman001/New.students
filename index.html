<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Billiard Glide 賽事設置版</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; background: #070a13; color: white; position: fixed; width: 100%; height: 100%; overflow: hidden; font-family: 'Segoe UI', system-ui, sans-serif; }
        #app { display: flex; flex-direction: column; height: 100%; }
        #table-wrapper { flex: 1; display: flex; justify-content: center; align-items: center; background: #000; position: relative; }
        .stat-card { background: rgba(15, 23, 42, 0.8); border: 1px solid #1e293b; padding: 4px 10px; border-radius: 8px; text-align: center; }
        .controls { background: #0f172a; padding: 15px; border-top: 1px solid #334155; }
        .config-overlay { position: absolute; inset: 0; background: rgba(0,0,0,0.85); z-index: 1000; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 20px; }
    </style>
</head>
<body>

<div id="app">
    <div id="config-ui" class="config-overlay">
        <h2 class="text-emerald-400 font-black text-xl mb-6 tracking-widest">後台賽事設定</h2>
        <div class="space-y-4 w-full max-w-xs">
            <div class="flex justify-between items-center">
                <span>每隊球數</span>
                <input type="number" id="ball-count-input" value="6" class="bg-slate-800 border border-slate-600 rounded px-3 py-1 w-20 text-center">
            </div>
            <div class="text-xs text-slate-400">加分球：黑球 x 1, 白球 x 1 (固定)</div>
            <button id="start-setup-btn" class="w-full bg-emerald-600 py-3 rounded-xl font-black mt-4 shadow-lg shadow-emerald-900/40">進入擺球模式</button>
        </div>
    </div>

    <div class="p-2 flex justify-around bg-slate-900 border-b border-slate-800">
        <div class="stat-card">
            <div class="text-[10px] text-red-400 uppercase font-bold">Team A</div>
            <div class="text-lg font-black" id="stat-a">進球: 0</div>
        </div>
        <div class="stat-card">
            <div class="text-[10px] text-yellow-500 uppercase font-bold">加分項</div>
            <div class="text-xs" id="bonus-info">黑: 未進 | 母: 在場</div>
        </div>
        <div class="stat-card">
            <div class="text-[10px] text-blue-400 uppercase font-bold">Team B</div>
            <div class="text-lg font-black" id="stat-b">進球: 0</div>
        </div>
    </div>

    <div id="table-wrapper">
        <div id="canvas-container"></div>
        <div id="proximity-info" class="absolute bottom-4 right-4 text-[10px] text-emerald-500/80 font-mono">距離底線: --</div>
    </div>

    <div class="controls flex flex-col gap-2">
        <div id="status-bar" class="text-center text-[10px] py-1 text-emerald-400 font-bold tracking-widest bg-emerald-500/10 rounded">請設定賽程</div>
        <div class="flex gap-2">
            <button id="undo-btn" class="flex-1 bg-slate-800 text-white py-3 rounded-xl font-bold text-xs opacity-50" disabled>復原上一球</button>
            <button id="main-btn" class="flex-[3] bg-emerald-600 text-white py-3 rounded-xl font-bold text-sm shadow-lg active:scale-95 transition-all">確認配置</button>
        </div>
    </div>
</div>

<script>
    const { Engine, Render, Runner, Bodies, Composite, Events, Vector, Body } = Matter;
    const engine = Engine.create();
    engine.gravity.y = 0;

    const wrapper = document.getElementById('table-wrapper');
    const container = document.getElementById('canvas-container');
    const tableH = wrapper.clientHeight - 20, tableW = tableH / 2;
    const scale = tableW / 137;
    const ballR = (5.7 * scale) / 2.2;
    const gSize = ballR * 2.8; // 袋口缺口寬度

    const render = Render.create({
        element: container, engine: engine,
        options: { width: tableW, height: tableH, wireframes: false, background: '#064e3b' }
    });

    // 遊戲數據
    let gameState = 'CONFIG';
    let teamABallsCount = 0, teamBBallsCount = 0;
    let turn = 'A', balls = [], activeBall = null, history = null;
    let dragBall = null, startPt = null;

    // 三角形區域定義
    const triY = tableH * 0.15;
    const triW = 50 * scale;
    const triRect = { minX: tableW/2 - triW/2, maxX: tableW/2 + triW/2, minY: triY, maxY: triY + triW };

    Events.on(render, 'afterRender', () => {
        const ctx = render.context;
        // 1. 發球線
        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
        ctx.setLineDash([2, 4]);
        ctx.beginPath(); ctx.moveTo(0, tableH * 0.75); ctx.lineTo(tableW, tableH * 0.75); ctx.stroke();
        
        // 2. 精美三角形虛線 UI
        ctx.strokeStyle = '#34d399'; ctx.setLineDash([5, 5]); ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(tableW/2, triY + triW); 
        ctx.lineTo(tableW/2 - triW/2, triY);
        ctx.lineTo(tableW/2 + triW/2, triY);
        ctx.closePath(); ctx.stroke(); ctx.setLineDash([]);
        
        // 3. 三角形區域提示
        if (gameState === 'SETTING') {
            ctx.fillStyle = 'rgba(52, 211, 153, 0.05)';
            ctx.fill();
        }

        // 4. 擊球輔助
        if (gameState === 'READY' && dragBall && startPt) {
            ctx.beginPath(); ctx.moveTo(dragBall.position.x, dragBall.position.y);
            const diff = Vector.sub(startPt, Matter.Mouse.create(render.canvas).position); // 簡化處理
            ctx.lineTo(dragBall.position.x + (startPt.x - currentMouseX)*10, dragBall.position.y + (startPt.y - currentMouseY)*10);
            ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.stroke();
        }
    });

    function initTable() {
        Composite.clear(engine.world);
        const cOpt = { isStatic: true, restitution: 0.9, friction: 0.01, render: { fillStyle: '#064e3b', strokeStyle: '#059669', lineWidth: 1 } };
        const w = 15 * scale;
        // 真正開口的物理邊框
        Composite.add(engine.world, [
            Bodies.rectangle(tableW/2, -w/2, tableW - gSize*2, w, cOpt), // 上
            Bodies.rectangle(tableW/2, tableH+w/2, tableW - gSize*2, w, cOpt), // 下
            Bodies.rectangle(-w/2, tableH*0.25, w, tableH*0.5 - gSize, cOpt), // 左上
            Bodies.rectangle(-w/2, tableH*0.75, w, tableH*0.5 - gSize, cOpt), // 左下
            Bodies.rectangle(tableW+w/2, tableH*0.25, w, tableH*0.5 - gSize, cOpt), // 右上
            Bodies.rectangle(tableW+w/2, tableH*0.75, w, tableH*0.5 - gSize, cOpt)  // 右下
        ]);
    }

    // 球體初始化
    function spawnInitialBalls() {
        const black = Bodies.circle(tableW/2, triY + 20, ballR, { label:'黑球', frictionAir:0.015, render:{fillStyle:'#000', strokeStyle:'#fbbf24', lineWidth:2} });
        const white = Bodies.circle(tableW/2, triY + 40, ballR, { label:'母球', frictionAir:0.015, render:{fillStyle:'#fff', strokeStyle:'#94a3b8', lineWidth:2} });
        balls = [black, white];
        Composite.add(engine.world, balls);
    }

    // 拖動邏輯 (含三角形區域限制)
    let currentMouseX, currentMouseY;
    container.addEventListener('touchstart', (e) => {
        const t = e.touches[0]; const rect = container.getBoundingClientRect();
        const pt = { x: t.clientX - rect.left, y: t.clientY - rect.top };
        balls.forEach(b => {
            if (Vector.magnitude(Vector.sub(b.position, pt)) < 25) {
                if (gameState === 'SETTING' || (gameState === 'SPAWNED' && b === activeBall)) dragBall = b;
                if (gameState === 'READY' && b === activeBall) { dragBall = b; startPt = pt; }
            }
        });
    });

    container.addEventListener('touchmove', (e) => {
        if (!dragBall) return;
        const t = e.touches[0]; const rect = container.getBoundingClientRect();
        const pt = { x: t.clientX - rect.left, y: t.clientY - rect.top };
        currentMouseX = pt.x; currentMouseY = pt.y;

        if (gameState === 'SETTING') {
            // 限制加分球只能在三角形內
            const buffer = ballR;
            const clampedX = Math.max(triRect.minX + buffer, Math.min(triRect.maxX - buffer, pt.x));
            const clampedY = Math.max(triRect.minY + buffer, Math.min(triRect.maxY - buffer, pt.y));
            Body.setPosition(dragBall, { x: clampedX, y: clampedY });
        } else if (gameState === 'SPAWNED') {
            if (pt.y > tableH * 0.75) Body.setPosition(dragBall, pt);
        }
        e.preventDefault();
    }, {passive:false});

    container.addEventListener('touchend', (e) => {
        if (gameState === 'READY' && dragBall && startPt) {
            const f = Vector.sub(startPt, {x: currentMouseX, y: currentMouseY});
            if (Vector.magnitude(f) > 10) {
                saveHistory();
                Body.applyForce(dragBall, dragBall.position, Vector.mult(f, 0.00075 * dragBall.mass));
                gameState = 'MOVING';
                checkStop();
            }
        }
        dragBall = null;
    });

    // 控制流
    document.getElementById('start-setup-btn').addEventListener('click', () => {
        document.getElementById('config-ui').style.display = 'none';
        gameState = 'SETTING';
        initTable();
        spawnInitialBalls();
        document.getElementById('status-bar').innerText = '佈置：請將加分球放在三角形內';
    });

    document.getElementById('main-btn').addEventListener('click', () => {
        if (gameState === 'SETTING') {
            gameState = 'IDLE'; 
            document.getElementById('main-btn').innerText = `玩家 ${turn} 發球`;
            document.getElementById('status-bar').innerText = '配置完成！點擊開始發球';
        } else if (gameState === 'IDLE') {
            spawnPlayerBall();
        } else if (gameState === 'SPAWNED') {
            gameState = 'READY';
            document.getElementById('main-btn').innerText = '向後拉擊球';
        }
    });

    function spawnPlayerBall() {
        const ball = Bodies.circle(tableW/2, tableH * 0.85, ballR, {
            restitution:0.9, frictionAir:0.015,
            render: { fillStyle: turn==='A'?'#ef4444':'#3b82f6', strokeStyle:'#fff', lineWidth:2 },
            label: turn+'隊'
        });
        activeBall = ball; balls.push(ball);
        Composite.add(engine.world, ball);
        gameState = 'SPAWNED';
        document.getElementById('main-btn').innerText = '確定位置';
    }

    function checkStop() {
        const i = setInterval(() => {
            if (balls.every(b => b.speed < 0.1)) {
                gameState = 'IDLE';
                turn = turn === 'A' ? 'B' : 'A';
                document.getElementById('main-btn').innerText = `玩家 ${turn} 發球`;
                document.getElementById('status-bar').innerText = `輪到 ${turn} 隊`;
                updateProximity();
                clearInterval(i);
            }
        }, 600);
    }

    function updateProximity() {
        let bestDist = Infinity, winner = "--";
        balls.forEach(b => {
            if (b.label.includes('隊')) {
                const distToBot = tableH - b.position.y;
                if (distToBot < bestDist) { bestDist = distToBot; winner = b.label; }
            }
        });
        document.getElementById('proximity-info').innerText = `最靠近底線: ${winner}`;
    }

    // 進球判斷 (基於越界判斷)
    Events.on(engine, 'afterUpdate', () => {
        balls.forEach((b, idx) => {
            if (b.position.x < -ballR || b.position.x > tableW + ballR || 
                b.position.y < -ballR || b.position.y > tableH + ballR) {
                
                if (b.label === 'A隊') teamABallsCount++;
                if (b.label === 'B隊') teamBBallsCount++;
                if (b.label === '黑球') document.getElementById('bonus-info').innerText = "黑: 已進 | 母: 在場";
                if (b.label === '母球') document.getElementById('bonus-info').innerText = "黑: -- | 母: 洗袋";

                Composite.remove(engine.world, b);
                balls.splice(idx, 1);
                updateStats();
            }
        });
    });

    function updateStats() {
        document.getElementById('stat-a').innerText = `進球: ${teamABallsCount}`;
        document.getElementById('stat-b').innerText = `進球: ${teamBBallsCount}`;
    }

    function saveHistory() {
        history = {
            balls: balls.map(b => ({ x: b.position.x, y: b.position.y, label: b.label, color: b.render.fillStyle, stroke: b.render.strokeStyle, id: b.id })),
            teamABallsCount, teamBBallsCount, turn, activeBallId: activeBall ? activeBall.id : null
        };
        document.getElementById('undo-btn').disabled = false;
        document.getElementById('undo-btn').classList.remove('opacity-50');
    }

    document.getElementById('undo-btn').addEventListener('click', () => {
        if (!history) return;
        Composite.clear(engine.world, true);
        initTable();
        balls = history.balls.map(h => {
            const b = Bodies.circle(h.x, h.y, ballR, { label:h.label, frictionAir:0.015, render:{fillStyle:h.color, strokeStyle:h.stroke, lineWidth:3}});
            if (h.id === history.activeBallId) activeBall = b;
            return b;
        });
        Composite.add(engine.world, balls);
        teamABallsCount = history.teamABallsCount; teamBBallsCount = history.teamBBallsCount; turn = history.turn;
        gameState = 'READY';
        updateStats();
        history = null;
        document.getElementById('undo-btn').disabled = true;
        document.getElementById('undo-btn').classList.add('opacity-50');
    });

    Render.run(render);
    Runner.run(Runner.create(), engine);
</script>
</body>
</html>

