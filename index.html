<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Billiard Pro v11 - Resource Management</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; background: #020617; color: #f8fafc; position: fixed; width: 100%; height: 100%; overflow: hidden; font-family: system-ui, -apple-system; }
        #app { display: flex; flex-direction: column; height: 100%; }
        #table-wrapper { flex: 1; display: flex; justify-content: center; align-items: center; background: radial-gradient(circle, #0f172a 0%, #000 100%); position: relative; }
        #canvas-container { position: relative; border-radius: 12px; overflow: hidden; box-shadow: 0 0 60px rgba(0,0,0,0.5); }
        .config-overlay { position: absolute; inset: 0; background: rgba(7, 10, 19, 0.98); z-index: 2000; display: flex; flex-direction: column; align-items: center; justify-content: center; backdrop-filter: blur(15px); }
        .score-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; padding: 12px; background: #0f172a; border-bottom: 2px solid #1e293b; }
        .team-status { background: #1e293b; padding: 8px; border-radius: 12px; border-bottom: 3px solid transparent; }
        .pocket-hole { position: absolute; border-radius: 50%; background: #000; box-shadow: inset 0 0 15px rgba(255,255,255,0.1); pointer-events: none; z-index: 1; }
    </style>
</head>
<body>

<div id="app">
    <div id="config-ui" class="config-overlay">
        <div class="bg-slate-900 p-8 rounded-[2rem] border border-slate-700 shadow-2xl w-80">
            <h1 class="text-2xl font-black text-emerald-400 mb-6 text-center italic tracking-tighter uppercase">Tournament v11</h1>
            <div class="space-y-4">
                <div>
                    <label class="text-[10px] text-slate-500 font-bold uppercase">參賽隊伍</label>
                    <select id="team-count" class="w-full bg-slate-800 border border-slate-700 rounded-xl p-3 text-sm mt-1 outline-none">
                        <option value="2">2 隊對抗</option>
                        <option value="3">3 隊大亂鬥</option>
                        <option value="4">4 隊巔峰賽</option>
                    </select>
                </div>
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label class="text-[10px] text-slate-500 font-bold uppercase">總球數/隊</label>
                        <input type="number" id="ball-qty" value="5" class="w-full bg-slate-800 border border-slate-700 rounded-xl p-3 text-sm mt-1 text-center">
                    </div>
                    <div>
                        <label class="text-[10px] text-slate-500 font-bold uppercase">加分球(局)</label>
                        <input type="number" id="black-qty" value="2" class="w-full bg-slate-800 border border-slate-700 rounded-xl p-3 text-sm mt-1 text-center">
                    </div>
                </div>
                <button id="start-btn" class="w-full bg-emerald-600 hover:bg-emerald-500 py-4 rounded-2xl font-black text-lg mt-2 shadow-lg transition-all">開局啟動</button>
            </div>
        </div>
    </div>

    <div id="score-board" class="score-grid"></div>

    <div id="table-wrapper">
        <div id="canvas-container"></div>
        <div id="prox-alert" class="absolute top-4 left-1/2 -translate-x-1/2 bg-black/60 px-4 py-1 rounded-full border border-white/10 text-[10px] text-emerald-400 z-10 font-mono"></div>
    </div>

    <div class="bg-slate-900 p-4 flex flex-col gap-3 border-t border-slate-800">
        <div class="flex justify-between items-center text-[10px] font-bold uppercase text-slate-500">
            <span id="game-info" class="text-yellow-500">準備開球</span>
            <label class="flex items-center gap-1 cursor-pointer">
                <input type="checkbox" id="ai-fast" checked> AI 瞬間擊球
            </label>
        </div>
        <div class="flex gap-2">
            <button id="undo-btn" class="bg-slate-800 px-6 rounded-2xl font-bold text-[10px] opacity-30" disabled>UNDO</button>
            <button id="main-btn" class="flex-1 bg-emerald-600 py-4 rounded-2xl font-black text-xs uppercase tracking-widest shadow-xl">開始發球</button>
        </div>
    </div>
</div>

<script>
    /** * Billiard Elite v11 
     * 重點：Ammo 消耗系統、中袋邊界開洞、力道擬人化 
     */
    const { Engine, Render, Runner, Bodies, Composite, Events, Vector, Body } = Matter;

    const engine = Engine.create();
    engine.velocityIterations = 15;
    engine.gravity.y = 0;

    const container = document.getElementById('canvas-container');
    const tableH = document.getElementById('table-wrapper').clientHeight - 60;
    const tableW = tableH / 2;
    const scale = tableW / 137;
    const ballR = (5.7 * scale) / 2.3;
    const pkSize = ballR * 2.1;
    const colors = ['#f43f5e', '#3b82f6', '#eab308', '#a855f7'];

    const render = Render.create({
        element: container, engine: engine,
        options: { width: tableW, height: tableH, wireframes: false, background: '#064e3b' }
    });

    let balls = [], activeBall = null, gameState = 'CONFIG', turnIdx = 0, strikerIdx = 0;
    let cfg = { teamCount: 2, ballQty: 5, blackQty: 2 };
    let teamData = []; // 存儲得分與剩餘球數

    // --- 1. 真實物理邊界：六袋口開洞 ---
    function buildCushions() {
        Composite.clear(engine.world);
        const opt = { isStatic: true, restitution: 0.85, friction: 0.02, render: { fillStyle: '#1e293b' } };
        const th = 100; // 牆厚
        const g = pkSize * 1.5; // 洞口間隙

        const walls = [
            // 頂邊兩段
            Bodies.rectangle(tableW/4, -th/2, tableW/2 - g, th, opt),
            Bodies.rectangle(tableW*0.75, -th/2, tableW/2 - g, th, opt),
            // 底邊兩段
            Bodies.rectangle(tableW/4, tableH + th/2, tableW/2 - g, th, opt),
            Bodies.rectangle(tableW*0.75, tableH + th/2, tableW/2 - g, th, opt),
            // 左側三段 (中袋開洞)
            Bodies.rectangle(-th/2, tableH*0.18, th, tableH*0.36 - g, opt),
            Bodies.rectangle(-th/2, tableH/2, th, g, { ...opt, isSensor: true, render: { opacity: 0 } }), // 中袋感應區
            Bodies.rectangle(-th/2, tableH*0.82, th, tableH*0.36 - g, opt),
            // 右側三段
            Bodies.rectangle(tableW + th/2, tableH*0.18, th, tableH*0.36 - g, opt),
            Bodies.rectangle(tableW + th/2, tableH/2, th, g, { ...opt, isSensor: true, render: { opacity: 0 } }),
            Bodies.rectangle(tableW + th/2, tableH*0.82, th, tableH*0.36 - g, opt)
        ];
        Composite.add(engine.world, walls);

        // 視覺黑洞
        const pks = [{x:0,y:0},{x:tableW,y:0},{x:0,y:tableH/2},{x:tableW,y:tableH/2},{x:0,y:tableH},{x:tableW,y:tableH}];
        pks.forEach(p => {
            const h = document.createElement('div');
            h.className = 'pocket-hole';
            h.style.width = h.style.height = (pkSize * 2.2) + 'px';
            h.style.left = (p.x - pkSize * 1.1) + 'px';
            h.style.top = (p.y - pkSize * 1.1) + 'px';
            container.appendChild(h);
        });
    }

    // --- 2. 初始化局數 ---
    function initTournament() {
        buildCushions();
        teamData = Array.from({length: cfg.teamCount}, () => ({ score: 0, ammo: cfg.ballQty }));
        updateUI();

        // 放置本局黑球
        const triY = tableH * 0.2;
        for(let i=0; i<cfg.blackQty; i++) {
            balls.push(createBall(tableW/2, triY + i*25, '#111', 'BLACK', '#fbbf24'));
        }
        balls.push(createBall(tableW/2, triY + (cfg.blackQty*25)+20, '#fff', 'WHITE', '#94a3b8'));
        
        gameState = 'SETTING';
        document.getElementById('game-info').innerText = "佈置模式";
    }

    function createBall(x, y, color, label, stroke) {
        const b = Bodies.circle(x, y, ballR, {
            label, restitution: 0.9, frictionAir: 0.015,
            render: { fillStyle: color, strokeStyle: stroke, lineWidth: 2.5 }
        });
        Composite.add(engine.world, b);
        return b;
    }

    // --- 3. 擊球力道與 Ammo 邏輯 ---
    let dragStart = null, currentMouse = null;

    container.addEventListener('touchstart', (e) => {
        const rect = container.getBoundingClientRect();
        const pt = { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
        balls.forEach(b => {
            if (Vector.magnitude(Vector.sub(b.position, pt)) < 30) {
                if (gameState === 'SETTING' && (b.label === 'BLACK' || b.label === 'WHITE')) activeBall = b;
                if (gameState === 'SPAWNED' && b === activeBall) activeBall = b;
                if (gameState === 'READY' && b === activeBall) { dragStart = pt; currentMouse = pt; }
            }
        });
    });

    container.addEventListener('touchmove', (e) => {
        const rect = container.getBoundingClientRect();
        const pt = { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
        currentMouse = pt;
        if (activeBall && gameState === 'SETTING') Body.setPosition(activeBall, pt);
        if (activeBall && gameState === 'SPAWNED' && pt.y > tableH * 0.72) Body.setPosition(activeBall, pt);
        e.preventDefault();
    }, { passive: false });

    container.addEventListener('touchend', () => {
        if (gameState === 'READY' && dragStart && currentMouse) {
            // 優化力道判斷：增加最大閾值
            const rawDist = Vector.magnitude(Vector.sub(dragStart, currentMouse));
            const power = Math.min(rawDist * 0.0001, 0.022); // 限制在 0.022 以下，防止穿牆
            const dir = Vector.normalise(Vector.sub(dragStart, currentMouse));
            
            if (power > 0.003) {
                strikerIdx = turnIdx;
                teamData[turnIdx].ammo--; // 擊球即消耗彈藥
                updateUI();
                launch(Vector.mult(dir, power));
            }
        }
        dragStart = null;
    });

    function launch(force) {
        Body.applyForce(activeBall, activeBall.position, force);
        gameState = 'MOVING';
        document.getElementById('game-info').innerText = "球運行中...";
        checkStop();
    }

    function checkStop() {
        const check = setInterval(() => {
            if (balls.every(b => b.speed < 0.15)) {
                clearInterval(check);
                onTurnEnd();
            }
        }, 600);
    }

    function onTurnEnd() {
        findLead();
        // 尋找下一個還有球的隊伍
        let nextIdx = (turnIdx + 1) % cfg.teamCount;
        let attempts = 0;
        while(teamData[nextIdx].ammo <= 0 && attempts < cfg.teamCount) {
            nextIdx = (nextIdx + 1) % cfg.teamCount;
            attempts++;
        }

        if (attempts >= cfg.teamCount && teamData.every(t => t.ammo <= 0)) {
            document.getElementById('game-info').innerText = "比賽結束！";
            return;
        }

        turnIdx = nextIdx;
        gameState = 'IDLE';
        document.getElementById('game-info').innerText = `輪到 Team ${String.fromCharCode(65+turnIdx)}`;
        document.getElementById('main-btn').innerText = `隊伍 ${String.fromCharCode(65+turnIdx)} 發球`;
        
        if (turnIdx > 0 && document.getElementById('ai-fast').checked) setTimeout(aiThink, 1000);
    }

    // --- 4. 進球規則與桌面判定 ---
    Events.on(engine, 'afterUpdate', () => {
        balls.forEach((b, idx) => {
            // 物理邊界外即為進球
            if (b.position.x < -15 || b.position.x > tableW + 15 || b.position.y < -15 || b.position.y > tableH + 15) {
                const label = b.label;
                // 規則：進對手球加分，進黑球全場加分
                if (label.includes('TEAM') && label !== `TEAM_${strikerIdx}`) {
                    teamData[strikerIdx].score++;
                } else if (label === 'BLACK') {
                    teamData[strikerIdx].score += 3; // 黑球大加分
                }
                
                Composite.remove(engine.world, b);
                balls.splice(idx, 1);
                updateUI();
            }
        });
    });

    function updateUI() {
        const sb = document.getElementById('score-board');
        sb.innerHTML = '';
        teamData.forEach((t, i) => {
            sb.innerHTML += `
                <div class="team-status" style="border-color: ${colors[i]}">
                    <div class="flex justify-between items-center mb-1">
                        <span class="text-[9px] font-black text-slate-400">TEAM ${String.fromCharCode(65+i)}</span>
                        <span class="text-[9px] bg-slate-700 px-2 rounded-full">Ammo: ${t.ammo}</span>
                    </div>
                    <div class="text-xl font-black" style="color: ${colors[i]}">${t.score}</div>
                </div>`;
        });
    }

    // --- 5. AI 與功能控制 ---
    function aiThink() {
        spawnNew();
        setTimeout(() => {
            gameState = 'READY';
            const target = balls.find(b => b.label === 'BLACK' || (b.label.includes('TEAM') && b.label !== `TEAM_${turnIdx}`)) || balls[0];
            const dir = Vector.normalise(Vector.sub(target.position, activeBall.position));
            strikerIdx = turnIdx;
            teamData[turnIdx].ammo--;
            updateUI();
            launch(Vector.mult(dir, 0.012 + Math.random()*0.005));
        }, 1200);
    }

    document.getElementById('start-btn').addEventListener('click', () => {
        cfg = { 
            teamCount: parseInt(document.getElementById('team-count').value),
            ballQty: parseInt(document.getElementById('ball-qty').value),
            blackQty: parseInt(document.getElementById('black-qty').value)
        };
        document.getElementById('config-ui').classList.add('hidden');
        initTournament();
    });

    document.getElementById('main-btn').addEventListener('click', () => {
        if (gameState === 'SETTING') { gameState = 'IDLE'; document.getElementById('main-btn').innerText = "開球"; }
        else if (gameState === 'IDLE') {
            if (teamData[turnIdx].ammo > 0) spawnNew();
            else onTurnEnd();
        }
        else if (gameState === 'SPAWNED') { gameState = 'READY'; document.getElementById('main-btn').innerText = "拉桿擊球"; }
    });

    function spawnNew() {
        activeBall = createBall(tableW/2, tableH * 0.85, colors[turnIdx], `TEAM_${turnIdx}`, '#fff');
        balls.push(activeBall);
        gameState = 'SPAWNED';
        document.getElementById('main-btn').innerText = "確認位置";
    }

    function findLead() {
        let minV = Infinity, tag = "--";
        balls.forEach(b => { if (b.position.y < minV) { minV = b.position.y; tag = b.label; } });
        document.getElementById('prox-alert').innerText = `最頂端領先: ${tag}`;
    }

    // 繪圖輔助
    Events.on(render, 'afterRender', () => {
        const ctx = render.context;
        // 發球線
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.beginPath(); ctx.moveTo(0, tableH*0.72); ctx.lineTo(tableW, tableH*0.72); ctx.stroke();

        // 擊球導引線
        if (gameState === 'READY' && dragStart && currentMouse) {
            const dx = dragStart.x - currentMouse.x, dy = dragStart.y - currentMouse.y;
            ctx.beginPath(); ctx.moveTo(activeBall.position.x, activeBall.position.y);
            ctx.lineTo(activeBall.position.x + dx*8, activeBall.position.y + dy*8);
            ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 1.5; ctx.stroke();
            
            // 力度表
            const p = Math.min(Vector.magnitude({x:dx, y:dy}), 100);
            ctx.beginPath(); ctx.arc(activeBall.position.x, activeBall.position.y, p, 0, Math.PI*2);
            ctx.strokeStyle = p > 70 ? '#f43f5e' : '#10b981'; ctx.stroke();
        }
    });

    Render.run(render); Runner.run(Runner.create(), engine);
</script>
</body>
</html>

