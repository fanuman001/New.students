<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Billiard AI Strategic v13</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; background: #020617; color: #f8fafc; position: fixed; width: 100%; height: 100%; overflow: hidden; font-family: sans-serif; }
        #app { display: flex; flex-direction: column; height: 100%; }
        #table-wrapper { flex: 1; display: flex; justify-content: center; align-items: center; background: #000; position: relative; }
        #canvas-container { position: relative; border: 4px solid #334155; border-radius: 20px; overflow: hidden; background: #064e3b; }
        .score-panel { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; padding: 12px; background: #0f172a; border-bottom: 2px solid #1e293b; }
        .team-box { background: #1e293b; padding: 10px; border-radius: 12px; border-left: 4px solid transparent; }
        .active-turn { border-color: #10b981 !important; background: #1e293b; box-shadow: inset 0 0 10px rgba(16,185,129,0.2); }
        .pocket { position: absolute; background: #000; border-radius: 50%; z-index: 1; pointer-events: none; }
    </style>
</head>
<body>

<div id="app">
    <div id="config-ui" class="absolute inset-0 bg-slate-950/95 z-[2000] flex flex-col items-center justify-center p-6 backdrop-blur-md">
        <div class="bg-slate-900 p-8 rounded-3xl border border-slate-700 w-full max-w-xs shadow-2xl">
            <h1 class="text-xl font-black text-emerald-400 mb-6 text-center italic">AI STRATEGY v13</h1>
            <div class="space-y-4">
                <div>
                    <label class="text-[10px] text-slate-500 font-bold uppercase">發球次數 (Ammo)</label>
                    <input type="number" id="ammo-qty" value="5" class="w-full bg-slate-800 border border-slate-700 rounded-xl p-3 text-center">
                </div>
                <button id="start-btn" class="w-full bg-emerald-600 py-4 rounded-2xl font-black shadow-lg">開始比賽</button>
            </div>
        </div>
    </div>

    <div id="score-board" class="score-panel"></div>

    <div id="table-wrapper">
        <div id="canvas-container"></div>
        <div id="ai-thought" class="absolute bottom-4 left-1/2 -translate-x-1/2 bg-black/60 px-4 py-1 rounded-full text-[10px] text-blue-400 font-mono opacity-0 transition-opacity">AI 思考中...</div>
    </div>

    <div class="bg-slate-900 p-4 border-t border-slate-800">
        <div class="flex justify-between items-center mb-3">
            <span id="game-status" class="text-xs font-bold text-yellow-500 uppercase">等待開球</span>
            <span class="text-[9px] text-slate-500">底線 +75 | 加分球 +50/+100</span>
        </div>
        <button id="main-btn" class="w-full bg-emerald-600 py-4 rounded-2xl font-black text-sm uppercase tracking-widest">發球佈置</button>
    </div>
</div>

<script>
    const { Engine, Render, Runner, Bodies, Composite, Events, Vector, Body } = Matter;

    const engine = Engine.create();
    engine.velocityIterations = 20;
    engine.gravity.y = 0;

    const container = document.getElementById('canvas-container');
    const tableH = document.getElementById('table-wrapper').clientHeight - 60;
    const tableW = tableH / 2;
    const scale = tableW / 137;
    const ballR = (5.7 * scale) / 2.3;
    const pkSize = ballR * 2.3;
    const colors = ['#f43f5e', '#3b82f6', '#eab308', '#a855f7'];

    const render = Render.create({
        element: container, engine: engine,
        options: { width: tableW, height: tableH, wireframes: false, background: '#064e3b' }
    });

    let balls = [], activeBall = null, gameState = 'CONFIG', turnIdx = 0, strikerIdx = 0;
    let teamData = [], cfg = { ammo: 5 };
    let bonusCount = 0;

    function initTable() {
        Composite.clear(engine.world);
        const opt = { isStatic: true, restitution: 0.8, friction: 0.02, render: { fillStyle: '#1e293b' } };
        const th = 100, g = pkSize * 1.5;

        Composite.add(engine.world, [
            Bodies.rectangle(tableW*0.25, -th/2, tableW*0.5-g, th, opt),
            Bodies.rectangle(tableW*0.75, -th/2, tableW*0.5-g, th, opt),
            Bodies.rectangle(tableW*0.25, tableH+th/2, tableW*0.5-g, th, opt),
            Bodies.rectangle(tableW*0.75, tableH+th/2, tableW*0.5-g, th, opt),
            Bodies.rectangle(-th/2, tableH*0.2, th, tableH*0.4-g, opt),
            Bodies.rectangle(-th/2, tableH*0.8, th, tableH*0.4-g, opt),
            Bodies.rectangle(tableW+th/2, tableH*0.2, th, tableH*0.4-g, opt),
            Bodies.rectangle(tableW+th/2, tableH*0.8, th, tableH*0.4-g, opt)
        ]);

        const pks = [{x:0,y:0},{x:tableW,y:0},{x:0,y:tableH/2},{x:tableW,y:tableH/2},{x:0,y:tableH},{x:tableW,y:tableH}];
        pks.forEach(p => {
            const h = document.createElement('div');
            h.className = 'pocket';
            h.style.width = h.style.height = (pkSize * 2.4) + 'px';
            h.style.left = (p.x - pkSize * 1.2) + 'px';
            h.style.top = (p.y - pkSize * 1.2) + 'px';
            container.appendChild(h);
        });
    }

    function createBall(x, y, color, label, stroke) {
        const b = Bodies.circle(x, y, ballR, {
            label, restitution: 0.9, frictionAir: 0.018,
            render: { fillStyle: color, strokeStyle: stroke, lineWidth: 2.5 }
        });
        Composite.add(engine.world, b);
        return b;
    }

    function updateScoreUI() {
        const sb = document.getElementById('score-board');
        sb.innerHTML = '';
        teamData.forEach((t, i) => {
            sb.innerHTML += `
                <div class="team-box ${turnIdx===i?'active-turn':''}" style="border-left-color: ${colors[i]}">
                    <div class="flex justify-between text-[10px] font-bold text-slate-500 uppercase">
                        <span>TEAM ${String.fromCharCode(65+i)}</span>
                        <span>AMMO: ${t.ammo}</span>
                    </div>
                    <div class="text-2xl font-black" style="color: ${colors[i]}">${t.score}</div>
                </div>`;
        });
    }

    // --- 智能 AI 決策核心 ---
    function aiDecisionLogic() {
        const aiIdx = turnIdx;
        const playerIdx = 0;
        const playerScore = teamData[playerIdx].score;
        
        // 1. 取得桌面分析
        let leadBall = null, minYSelf = Infinity, minYPlayer = Infinity;
        balls.forEach(b => {
            if (b.label === `TEAM_${aiIdx}` && b.position.y < minYSelf) minYSelf = b.position.y;
            if (b.label === `TEAM_${playerIdx}` && b.position.y < minYPlayer) minYPlayer = b.position.y;
        });

        const playerLeading = minYPlayer < minYSelf;
        const needToDefend = (playerScore >= 100 && playerLeading);

        // 2. 決定目標
        let target = null;
        let aiAction = "";

        if (needToDefend) {
            // 策略 A: 玩家分數高且佔領底線 -> 攻擊玩家的底線球
            target = balls.find(b => b.label === `TEAM_${playerIdx}` && b.position.y === minYPlayer);
            aiAction = "防禦: 撞走對手底線球";
        } 
        
        if (!target) {
            // 策略 B: 尋找容易進的加分球 (50分)
            const bonusBalls = balls.filter(b => b.label.includes('BONUS'));
            target = bonusBalls.find(b => Vector.magnitude(Vector.sub(b.position, activeBall.position)) < 200);
            if (target) aiAction = "進攻: 嘗試加分球";
        }

        if (!target) {
            // 策略 C: 選擇最近的球 (簡單得分)
            target = balls.filter(b => b !== activeBall).sort((a,b) => 
                Vector.magnitude(Vector.sub(a.position, activeBall.position)) - 
                Vector.magnitude(Vector.sub(b.position, activeBall.position))
            )[0];
            aiAction = "穩健: 獲取基本分";
        }

        // 3. 執行擊球 (帶有運氣/誤差成分)
        const dist = Vector.magnitude(Vector.sub(target.position, activeBall.position));
        const luckError = (dist / tableH) * 0.15; // 距離越長，誤差越大
        const angle = Vector.angle(activeBall.position, target.position) + (Math.random() - 0.5) * luckError;
        const dir = { x: Math.cos(angle), y: Math.sin(angle) };

        document.getElementById('ai-thought').innerText = `AI 決策: ${aiAction}`;
        document.getElementById('ai-thought').style.opacity = 1;

        setTimeout(() => {
            strikerIdx = aiIdx;
            teamData[aiIdx].ammo--;
            bonusCount = 0;
            launch(Vector.mult(dir, 0.012 + Math.random() * 0.005));
            document.getElementById('ai-thought').style.opacity = 0;
        }, 1200);
    }

    // --- 遊戲控制 ---
    function launch(f) {
        Body.applyForce(activeBall, activeBall.position, f);
        gameState = 'MOVING';
        checkStop();
    }

    function checkStop() {
        const timer = setInterval(() => {
            if (balls.every(b => b.speed < 0.1)) {
                clearInterval(timer);
                nextTurn();
            }
        }, 600);
    }

    function nextTurn() {
        if (teamData.every(t => t.ammo <= 0)) {
            // 結算底線獎勵
            let minY = Infinity, winner = -1;
            balls.forEach(b => {
                if (b.position.y < minY && b.label.includes('TEAM_')) {
                    minY = b.position.y; winner = parseInt(b.label.split('_')[1]);
                }
            });
            if (winner >= 0) teamData[winner].score += 75;
            updateScoreUI();
            document.getElementById('game-status').innerText = "比賽結束";
            return;
        }

        turnIdx = (turnIdx + 1) % 2;
        if (teamData[turnIdx].ammo <= 0) turnIdx = (turnIdx + 1) % 2;

        gameState = 'IDLE';
        document.getElementById('game-status').innerText = `輪到 Team ${String.fromCharCode(65+turnIdx)}`;
        updateScoreUI();

        if (turnIdx === 1) { // 電腦輪
            spawnNew();
            setTimeout(aiDecisionLogic, 1000);
        }
    }

    Events.on(engine, 'afterUpdate', () => {
        balls.forEach((b, idx) => {
            if (b.position.x < -10 || b.position.x > tableW + 10 || b.position.y < -10 || b.position.y > tableH + 10) {
                const striker = teamData[strikerIdx];
                if (b.label.includes('TEAM_')) {
                    if (parseInt(b.label.split('_')[1]) !== strikerIdx) striker.score += 25;
                } else if (b.label.includes('BONUS')) {
                    bonusCount++;
                    striker.score += (bonusCount === 1) ? 50 : 100;
                }
                Composite.remove(engine.world, b);
                balls.splice(idx, 1);
                updateScoreUI();
            }
        });
    });

    // 觸控邏輯 (玩家)
    container.addEventListener('touchstart', (e) => {
        if (turnIdx !== 0) return;
        const rect = container.getBoundingClientRect();
        const pt = { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
        if (activeBall && Vector.magnitude(Vector.sub(activeBall.position, pt)) < 30) {
            if (gameState === 'SPAWNED' || gameState === 'READY') dragStart = pt;
        }
    });

    let dragStart = null;
    container.addEventListener('touchmove', (e) => {
        if (turnIdx !== 0 || !dragStart) return;
        const rect = container.getBoundingClientRect();
        const pt = { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
        if (gameState === 'SPAWNED' && pt.y > tableH * 0.7) Body.setPosition(activeBall, pt);
        e.preventDefault();
    }, { passive: false });

    container.addEventListener('touchend', (e) => {
        if (turnIdx !== 0 || !dragStart) return;
        if (gameState === 'READY') {
            const rect = container.getBoundingClientRect();
            const pt = { x: e.changedTouches[0].clientX - rect.left, y: e.changedTouches[0].clientY - rect.top };
            const force = Vector.mult(Vector.sub(dragStart, pt), 0.00008);
            if (Vector.magnitude(force) > 0.002) {
                strikerIdx = 0; teamData[0].ammo--; bonusCount = 0;
                launch(force);
            }
        }
        dragStart = null;
    });

    document.getElementById('start-btn').addEventListener('click', () => {
        cfg.ammo = parseInt(document.getElementById('ammo-qty').value);
        teamData = [{score:0, ammo:cfg.ammo}, {score:0, ammo:cfg.ammo}];
        document.getElementById('config-ui').classList.add('hidden');
        initTable();
        const triY = tableH * 0.2;
        balls.push(createBall(tableW/2, triY, '#111', 'BONUS_B', '#fbbf24'));
        balls.push(createBall(tableW/2, triY + 30, '#fff', 'BONUS_W', '#94a3b8'));
        gameState = 'IDLE';
        updateScoreUI();
    });

    document.getElementById('main-btn').addEventListener('click', () => {
        if (gameState === 'IDLE') spawnNew();
        else if (gameState === 'SPAWNED') { gameState = 'READY'; document.getElementById('main-btn').innerText = "下拉擊球"; }
    });

    function spawnNew() {
        activeBall = createBall(tableW/2, tableH * 0.85, colors[turnIdx], `TEAM_${turnIdx}`, '#fff');
        balls.push(activeBall);
        gameState = 'SPAWNED';
        document.getElementById('main-btn').innerText = "確認位置";
    }

    Render.run(render); Runner.run(Runner.create(), engine);
</script>
</body>
</html>

