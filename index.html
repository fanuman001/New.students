<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Billiard Glide 9尺標準戰術版</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #020617; touch-action: none; font-family: sans-serif; }
        #table-container { 
            width: 90vw; 
            height: 80vh; 
            margin: 10px auto;
            position: relative;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body class="flex flex-col items-center">

    <div class="w-full bg-slate-900 p-2 text-center text-white border-b border-emerald-500">
        <h1 class="text-sm font-bold text-emerald-400">9FT 標準桌模擬器</h1>
        <div id="game-status" class="text-xs text-yellow-400 mt-1 uppercase font-black">第一步：請擺放黑球與母球</div>
    </div>

    <div id="table-container"></div>

    <div class="w-full bg-slate-900 p-4 flex flex-col items-center">
        <div id="ui-controls" class="w-full max-w-xs space-y-2">
            <button id="main-btn" class="w-full bg-emerald-600 text-white py-3 rounded-lg font-bold shadow-lg active:scale-95 transition-all">確認擺放</button>
            <p id="sub-info" class="text-[10px] text-slate-400 text-center uppercase tracking-tighter">當前：後攻方佈置球位</p>
        </div>
    </div>

    <script>
        const { Engine, Render, Runner, Bodies, Composite, Events, Vector, Body } = Matter;
        const engine = Engine.create();
        engine.gravity.y = 0;

        const container = document.getElementById('table-container');
        const viewW = container.clientWidth;
        // 強制 2:1 比例 (長比寬)
        const tableW = viewW;
        const tableH = viewW * 2; 
        container.style.height = tableH + 'px';

        const render = Render.create({
            element: container, engine: engine,
            options: { width: tableW, height: tableH, wireframes: false, background: 'transparent' }
        });

        // 比例尺 (137cm -> tableW)
        const scale = tableW / 137;
        const pocketR = (12 * scale); // 比例縮放的袋口
        const ballR = (5.7 * scale) / 2; // 標準球直徑約 5.7cm

        let gameState = 'SETTING'; // SETTING -> PLAYING
        let currentTeam = 'A';
        let aBalls = 6, bBalls = 6;
        let allBalls = [];
        let activeBall = null;

        // 1. 繪製標準球桌背景
        Events.on(render, 'beforeRender', (event) => {
            const ctx = render.context;
            ctx.fillStyle = '#166534'; // 頂級桌布綠
            ctx.fillRect(0, 0, tableW, tableH);
            
            // 腳顆星區 (頂部 1/4)
            ctx.fillStyle = 'rgba(251, 191, 36, 0.15)';
            ctx.fillRect(0, 0, tableW, tableH * 0.25);

            // 發球線 (底部 1/4)
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(0, tableH * 0.75); ctx.lineTo(tableW, tableH * 0.75); ctx.stroke();

            // 繪製六個大球洞
            ctx.fillStyle = '#000';
            const pocketPos = [
                {x: 0, y: 0}, {x: tableW, y: 0}, // 頂角
                {x: 0, y: tableH/2}, {x: tableW, y: tableH/2}, // 中袋
                {x: 0, y: tableH}, {x: tableW, y: tableH} // 底角
            ];
            pocketPos.forEach(p => {
                ctx.beginPath(); ctx.arc(p.x, p.y, pocketR, 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle = '#451a03'; ctx.lineWidth = 4; ctx.stroke();
            });

            // 預測線
            if (dragBall && startPt && currentMouse) {
                const diff = Vector.sub(startPt, currentMouse);
                ctx.beginPath(); ctx.moveTo(dragBall.position.x, dragBall.position.y);
                const endPos = Vector.add(dragBall.position, Vector.mult(diff, 6));
                ctx.lineTo(endPos.x, endPos.y);
                ctx.strokeStyle = '#fde047'; ctx.lineWidth = 3; ctx.setLineDash([5,5]); ctx.stroke(); ctx.setLineDash([]);
            }
        });

        // 2. 初始擺放黑球與母球
        const blackBall = Bodies.circle(tableW/2 - 20, 50, ballR, { 
            restitution: 0.8, frictionAir: 0.03, label: '黑球',
            render: { fillStyle: '#000', strokeStyle: '#fbbf24', lineWidth: 2 } 
        });
        const whiteBall = Bodies.circle(tableW/2 + 20, 50, ballR, { 
            restitution: 0.8, frictionAir: 0.03, label: '母球',
            render: { fillStyle: '#fff', strokeStyle: '#94a3b8', lineWidth: 2 } 
        });
        allBalls = [blackBall, whiteBall];
        Composite.add(engine.world, allBalls);

        // 3. 互動邏輯
        let dragBall = null, startPt = null, currentMouse = null;

        container.addEventListener('touchstart', (e) => {
            const t = e.touches[0];
            const rect = container.getBoundingClientRect();
            const pt = { x: t.clientX - rect.left, y: t.clientY - rect.top };
            
            allBalls.forEach(b => {
                if (Vector.magnitude(Vector.sub(b.position, pt)) < 30) {
                    if (gameState === 'SETTING' && (b.label === '黑球' || b.label === '母球')) {
                        dragBall = b;
                    } else if (gameState === 'PLAYING' && b === activeBall) {
                        dragBall = b; startPt = pt;
                    }
                }
            });
        }, {passive: false});

        container.addEventListener('touchmove', (e) => {
            if (!dragBall) return;
            const t = e.touches[0];
            const rect = container.getBoundingClientRect();
            const pt = { x: t.clientX - rect.left, y: t.clientY - rect.top };
            currentMouse = pt;

            if (gameState === 'SETTING') {
                Body.setPosition(dragBall, pt);
            }
            e.preventDefault();
        }, {passive: false});

        container.addEventListener('touchend', (e) => {
            if (!dragBall || gameState === 'SETTING') { dragBall = null; return; }
            const t = e.changedTouches[0];
            const rect = container.getBoundingClientRect();
            const pt = { x: t.clientX - rect.left, y: t.clientY - rect.top };
            
            const force = Vector.sub(startPt, pt);
            Body.applyForce(dragBall, dragBall.position, Vector.mult(force, 0.0003 * dragBall.mass));
            
            if (currentTeam === 'A') aBalls--; else bBalls--;
            dragBall = null; activeBall = null; startPt = null;
            checkStop();
        });

        // 4. 按鈕控制流程
        document.getElementById('main-btn').addEventListener('click', function() {
            if (gameState === 'SETTING') {
                gameState = 'PLAYING';
                this.innerText = '準備發球 (A1)';
                document.getElementById('game-status').innerText = '準備開賽：請發球';
                document.getElementById('sub-info').innerText = '輪流發球：A1 -> B1 -> A2...';
            } else {
                if (activeBall || (aBalls + bBalls === 0)) return;
                spawnBall();
            }
        });

        function spawnBall() {
            const ball = Bodies.circle(tableW/2, tableH * 0.85, ballR, {
                restitution: 0.8, frictionAir: 0.02,
                render: { fillStyle: currentTeam === 'A' ? '#ef4444' : '#3b82f6', strokeStyle: '#fff', lineWidth: 2 },
                label: currentTeam + '隊'
            });
            activeBall = ball;
            allBalls.push(ball);
            Composite.add(engine.world, ball);
            document.getElementById('game-status').innerText = `請 ${currentTeam} 隊推球`;
        }

        function checkStop() {
            const check = setInterval(() => {
                if (allBalls.every(b => b.speed < 0.2)) {
                    currentTeam = currentTeam === 'A' ? 'B' : 'A';
                    document.getElementById('main-btn').innerText = `下一位發球 (${currentTeam}${6- (currentTeam==='A'?aBalls:bBalls)+1})`;
                    clearInterval(check);
                }
            }, 1000);
        }

        // 牆壁
        Composite.add(engine.world, [
            Bodies.rectangle(tableW/2, -5, tableW, 10, {isStatic:true}),
            Bodies.rectangle(tableW/2, tableH+5, tableW, 10, {isStatic:true}),
            Bodies.rectangle(-5, tableH/2, 10, tableH, {isStatic:true}),
            Bodies.rectangle(tableW+5, tableH/2, 10, tableH, {isStatic:true})
        ]);

        Render.run(render);
        Runner.run(Runner.create(), engine);
    </script>
</body>
</html>

