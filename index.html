<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Billiard Pro Simulation V5</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; background: #020617; color: white; position: fixed; width: 100%; height: 100%; overflow: hidden; font-family: sans-serif; }
        #app { display: flex; flex-direction: column; height: 100%; }
        #table-wrapper { flex: 1; display: flex; justify-content: center; align-items: center; background: #000; position: relative; }
        canvas { border: 2px solid #334155; border-radius: 4px; }
        .controls { background: #0f172a; padding: 16px; border-top: 2px solid #1e293b; }
        .proximity-tag { position: absolute; top: 10px; right: 15px; background: rgba(0,0,0,0.6); padding: 4px 8px; border-radius: 4px; font-size: 11px; border: 1px solid #334155; }
    </style>
</head>
<body>

<div id="app">
    <div class="p-3 flex justify-between items-center bg-slate-900 border-b border-emerald-500/30">
        <div class="flex items-center gap-3">
            <span class="text-red-500 font-black text-xl">A: <span id="pts-a">0</span></span>
        </div>
        <h1 class="text-xs font-bold text-slate-400 tracking-widest uppercase">Tactical Billiard Pro</h1>
        <div class="flex items-center gap-3">
            <span class="text-blue-500 font-black text-xl">B: <span id="pts-b">0</span></span>
        </div>
    </div>

    <div id="table-wrapper">
        <div id="canvas-container"></div>
        <div class="proximity-tag text-emerald-400" id="proximity-info">最靠近底線: --</div>
    </div>

    <div class="controls flex flex-col gap-3">
        <div id="status-bar" class="text-center text-[11px] py-1 bg-slate-800 rounded text-yellow-500 uppercase font-bold tracking-tighter">
            初始化：請佈置黑球與母球
        </div>
        <div class="flex gap-2">
            <button id="undo-btn" class="flex-1 bg-slate-700 hover:bg-slate-600 text-white py-3 rounded-xl font-bold text-xs opacity-50 transition-all">返回上一球</button>
            <button id="main-btn" class="flex-[3] bg-emerald-600 hover:bg-emerald-500 text-white py-3 rounded-xl font-bold text-sm shadow-lg active:scale-95 transition-all">確定位置</button>
        </div>
    </div>
</div>

<script>
    const { Engine, Render, Runner, Bodies, Composite, Events, Vector, Body } = Matter;
    const engine = Engine.create();
    engine.gravity.y = 0;

    const wrapper = document.getElementById('table-wrapper');
    const container = document.getElementById('canvas-container');
    const tableH = wrapper.clientHeight - 30;
    const tableW = tableH / 2; // 2:1 比例
    const scale = tableW / 137;
    const ballR = (5.7 * scale) / 2.2;
    const pkSize = ballR * 2.8; // 袋口大小判定

    const render = Render.create({
        element: container, engine: engine,
        options: { width: tableW, height: tableH, wireframes: false, background: '#065f46' }
    });

    let gameState = 'SETTING', scoreA = 0, scoreB = 0, turn = 'A';
    let balls = [], activeBall = null, history = null;
    let dragBall = null, startPt = null, currentMouse = null;

    // 繪製專業桌面細節
    Events.on(render, 'afterRender', () => {
        const ctx = render.context;
        // 1. 袋口可視化 (深黑色圓洞)
        ctx.fillStyle = '#020617';
        const pks = [{x:0,y:0},{x:tableW,y:0},{x:0,y:tableH/2},{x:tableW,y:tableH/2},{x:0,y:tableH},{x:tableW,y:tableH}];
        pks.forEach(p => { ctx.beginPath(); ctx.arc(p.x, p.y, pkSize/1.2, 0, Math.PI*2); ctx.fill(); });

        // 2. 發球線
        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
        ctx.beginPath(); ctx.moveTo(0, tableH * 0.75); ctx.lineTo(tableW, tableH * 0.75); ctx.stroke();

        // 3. 修正後的反向三角形 (更往頂部移動)
        const triTopY = tableH * 0.15; 
        const triW = 40 * scale;
        ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.setLineDash([3,3]);
        ctx.beginPath();
        ctx.moveTo(tableW/2, triTopY + triW); // 頂角向下
        ctx.lineTo(tableW/2 - triW/2, triTopY);
        ctx.lineTo(tableW/2 + triW/2, triTopY);
        ctx.closePath(); ctx.stroke(); ctx.setLineDash([]);

        // 4. 擊球引導線
        if (gameState === 'READY' && dragBall && startPt && currentMouse) {
            const diff = Vector.sub(startPt, currentMouse);
            ctx.beginPath(); ctx.moveTo(dragBall.position.x, dragBall.position.y);
            const end = Vector.add(dragBall.position, Vector.mult(diff, 12));
            ctx.lineTo(end.x, end.y);
            ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.setLineDash([5,5]); ctx.stroke(); ctx.setLineDash([]);
            // 力量圈
            ctx.beginPath(); ctx.arc(dragBall.position.x, dragBall.position.y, Vector.magnitude(diff)*0.8, 0, Math.PI*2);
            ctx.strokeStyle = 'rgba(251,191,36,0.3)'; ctx.stroke();
        }
    });

    // --- 強化物理邊界 (具備真實開口的邊欄) ---
    function initCushions() {
        const cOpt = { isStatic: true, restitution: 0.9, friction: 0.02, render: { fillStyle: '#064e3b' } };
        const g = pkSize; // 袋口缺口寬度
        const w = 15 * scale; // 邊欄厚度
        Composite.add(engine.world, [
            Bodies.rectangle(tableW/2, -w/2, tableW - g*2, w, cOpt), // 上
            Bodies.rectangle(tableW/2, tableH+w/2, tableW - g*2, w, cOpt), // 下
            Bodies.rectangle(-w/2, tableH * 0.23, w, tableH*0.45 - g, cOpt), // 左上
            Bodies.rectangle(-w/2, tableH * 0.77, w, tableH*0.45 - g, cOpt), // 左下
            Bodies.rectangle(tableW+w/2, tableH * 0.23, w, tableH*0.45 - g, cOpt), // 右上
            Bodies.rectangle(tableW+w/2, tableH * 0.77, w, tableH*0.45 - g, cOpt)  // 右下
        ]);
    }
    initCushions();

    const black = Bodies.circle(tableW/2, tableH*0.18, ballR, { label:'黑球', restitution:0.9, frictionAir:0.012, render:{fillStyle:'#111', strokeStyle:'#fbbf24', lineWidth:3} });
    const white = Bodies.circle(tableW/2, tableH*0.18 + 50, ballR, { label:'母球', restitution:0.9, frictionAir:0.012, render:{fillStyle:'#eee', strokeStyle:'#94a3b8', lineWidth:3} });
    balls = [black, white];
    Composite.add(engine.world, balls);

    // 交互與 Undo 邏輯
    container.addEventListener('touchstart', (e) => {
        const t = e.touches[0]; const rect = container.getBoundingClientRect();
        const pt = { x: t.clientX - rect.left, y: t.clientY - rect.top };
        balls.forEach(b => {
            if (Vector.magnitude(Vector.sub(b.position, pt)) < 25) {
                if (gameState === 'SETTING') dragBall = b;
                if (gameState === 'SPAWNED' && b === activeBall) dragBall = b;
                if (gameState === 'READY' && b === activeBall) { dragBall = b; startPt = pt; currentMouse = pt; }
            }
        });
    }, {passive:false});

    container.addEventListener('touchmove', (e) => {
        if (!dragBall) return;
        const t = e.touches[0]; const rect = container.getBoundingClientRect();
        const pt = { x: t.clientX - rect.left, y: t.clientY - rect.top };
        currentMouse = pt;
        if (gameState === 'SETTING' || (gameState === 'SPAWNED' && pt.y > tableH*0.75)) {
            Body.setPosition(dragBall, pt);
        }
        e.preventDefault();
    }, {passive:false});

    container.addEventListener('touchend', () => {
        if (gameState === 'READY' && dragBall && startPt && currentMouse) {
            const f = Vector.sub(startPt, currentMouse);
            if (Vector.magnitude(f) > 10) {
                saveHistory();
                Body.applyForce(dragBall, dragBall.position, Vector.mult(f, 0.00075 * dragBall.mass));
                gameState = 'MOVING';
                document.getElementById('status-bar').innerText = '球在滾動中...';
                checkStop();
            }
        }
        dragBall = null;
    });

    const mainBtn = document.getElementById('main-btn');
    const undoBtn = document.getElementById('undo-btn');

    mainBtn.addEventListener('click', () => {
        if (gameState === 'SETTING') {
            gameState = 'IDLE'; mainBtn.innerText = `準備發球 (${turn})`;
            document.getElementById('status-bar').innerText = '佈置完成！點擊按鈕發球';
        } else if (gameState === 'IDLE') {
            spawn();
        } else if (gameState === 'SPAWNED') {
            gameState = 'READY'; mainBtn.innerText = '拉球擊發';
            document.getElementById('status-bar').innerText = '擊球模式：往球後方拖曳';
        }
    });

    undoBtn.addEventListener('click', () => { if (history) loadHistory(); });

    function spawn() {
        const ball = Bodies.circle(tableW/2, tableH * 0.85, ballR, {
            restitution:0.9, frictionAir:0.012,
            render: { fillStyle: turn==='A'?'#ef4444':'#3b82f6', strokeStyle:'#fff', lineWidth:2 },
            label: turn+'隊'
        });
        activeBall = ball; balls.push(ball);
        Composite.add(engine.world, ball);
        gameState = 'SPAWNED';
        mainBtn.innerText = '鎖定位置';
        document.getElementById('status-bar').innerText = '拖動球至發球區任意位置';
    }

    function checkStop() {
        const i = setInterval(() => {
            if (balls.every(b => b.speed < 0.1)) {
                gameState = 'IDLE';
                turn = turn === 'A' ? 'B' : 'A';
                mainBtn.innerText = `下一位發球 (${turn})`;
                document.getElementById('status-bar').innerText = `輪到 ${turn} 隊`;
                clearInterval(i);
            }
            updateProximity();
        }, 500);
    }

    function updateProximity() {
        let minD = Infinity, winner = "--";
        balls.forEach(b => {
            if (b.label.includes('隊')) {
                const distToBot = tableH - b.position.y;
                if (distToBot < minD) { minD = distToBot; winner = b.label; }
            }
        });
        document.getElementById('proximity-info').innerText = `最靠近底線: ${winner}`;
    }

    function saveHistory() {
        history = {
            balls: balls.map(b => ({ x: b.position.x, y: b.position.y, label: b.label, color: b.render.fillStyle, stroke: b.render.strokeStyle, id: b.id })),
            scoreA, scoreB, turn, activeBallId: activeBall ? activeBall.id : null
        };
        undoBtn.disabled = false; undoBtn.classList.remove('opacity-50');
    }

    function loadHistory() {
        Composite.clear(engine.world, true); initCushions();
        balls = history.balls.map(h => {
            const b = Bodies.circle(h.x, h.y, ballR, { label:h.label, restitution:0.9, frictionAir:0.012, render:{fillStyle:h.color, strokeStyle:h.stroke, lineWidth:3}});
            if (h.id === history.activeBallId) activeBall = b;
            return b;
        });
        Composite.add(engine.world, balls);
        scoreA = history.scoreA; scoreB = history.scoreB; turn = history.turn;
        gameState = 'READY'; // 直接返回擊球狀態
        mainBtn.innerText = '拉球擊發';
        document.getElementById('pts-a').innerText = scoreA; document.getElementById('pts-b').innerText = scoreB;
        document.getElementById('status-bar').innerText = '已還原！重新擊球';
        history = null; undoBtn.disabled = true; undoBtn.classList.add('opacity-50');
    }

    // 進洞計分邏輯修正
    Events.on(engine, 'afterUpdate', () => {
        balls.forEach((b, idx) => {
            const pks = [{x:0,y:0},{x:tableW,y:0},{x:0,y:tableH/2},{x:tableW,y:tableH/2},{x:0,y:tableH},{x:tableW,y:tableH}];
            pks.forEach(p => {
                if (Vector.magnitude(Vector.sub(b.position, p)) < pkSize) {
                    // 計分邏輯
                    if (b.label === '黑球') {
                        if (turn === 'B') scoreA += 50; else scoreB += 50; // 當前擊球的人加分
                    } else if (b.label === '母球') {
                        if (turn === 'B') scoreB += 50; else scoreA += 50; // 進母球給對方加分
                    } else if (b.label === 'A隊' && turn === 'B') {
                        scoreB += 25; // 擊中對方球進洞
                    } else if (b.label === 'B隊' && turn === 'A') {
                        scoreA += 25;
                    }
                    Composite.remove(engine.world, b);
                    balls.splice(idx, 1);
                    document.getElementById('pts-a').innerText = scoreA;
                    document.getElementById('pts-b').innerText = scoreB;
                }
            });
        });
    });

    Render.run(render);
    Runner.run(Runner.create(), engine);
</script>
</body>
</html>

