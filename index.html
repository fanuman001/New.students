<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Strategic Billiard Pro v14.4</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; background: #0f172a; color: #f8fafc; position: fixed; width: 100%; height: 100%; overflow: hidden; font-family: system-ui; }
        #app { display: flex; flex-direction: column; height: 100%; }
        #table-wrapper { flex: 1; display: flex; justify-content: center; align-items: center; background: #020617; position: relative; padding: 20px; }
        #canvas-container { position: relative; border: 12px solid #3e2723; border-radius: 24px; box-shadow: 0 20px 50px rgba(0,0,0,0.5); overflow: visible; background: #065f46; }
        .score-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; padding: 15px; background: #1e293b; border-bottom: 4px solid #0f172a; }
        .team-box { background: #334155; padding: 12px; border-radius: 16px; border-bottom: 4px solid rgba(0,0,0,0.2); transition: 0.3s; }
        .active-turn { border-color: #10b981 !important; transform: translateY(-2px); box-shadow: 0 4px 12px rgba(16,185,129,0.3); }
        .pocket-hole { position: absolute; background: radial-gradient(circle, #000 60%, #1a1a1a 100%); border-radius: 50%; z-index: 1; box-shadow: inset 0 5px 10px rgba(0,0,0,0.8); }
        #power-meter { position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%); width: 200px; height: 10px; background: #1e293b; border-radius: 5px; overflow: hidden; display: none; }
        #power-fill { width: 0%; height: 100%; background: linear-gradient(to right, #10b981, #facc15, #f43f5e); transition: 0.1s; }
    </style>
</head>
<body>

<div id="app">
    <div id="config-ui" class="absolute inset-0 bg-slate-950/95 z-[3000] flex items-center justify-center backdrop-blur-xl">
        <div class="bg-slate-900 p-8 rounded-[2rem] border border-slate-700 w-80 shadow-2xl">
            <h1 class="text-2xl font-black text-emerald-400 mb-6 text-center italic">PRO SETUP v14.4</h1>
            
            <div class="space-y-4 mb-8">
                <div>
                    <label class="text-[10px] text-slate-500 font-bold uppercase">每局彈藥</label>
                    <input type="number" id="ball-qty" value="5" class="w-full bg-slate-800 border border-slate-700 rounded-xl p-3 text-center text-xl font-bold">
                </div>
                <div class="flex justify-between items-center bg-slate-800 p-3 rounded-xl">
                    <span class="text-xs font-bold">瞄準線輔助</span>
                    <input type="checkbox" id="show-guideline" checked class="w-5 h-5 accent-emerald-500">
                </div>
                <div class="flex justify-between items-center bg-slate-800 p-3 rounded-xl">
                    <span class="text-xs font-bold">力道可視化</span>
                    <input type="checkbox" id="show-power" checked class="w-5 h-5 accent-emerald-500">
                </div>
            </div>
            
            <button id="start-btn" class="w-full bg-emerald-600 hover:bg-emerald-500 py-4 rounded-xl font-black text-lg transition-all active:scale-95 shadow-lg">進入猜拳</button>
        </div>
    </div>

    <div id="rps-ui" class="absolute inset-0 bg-slate-900/90 z-[2000] hidden flex items-center justify-center">
        <div class="text-center">
            <h2 class="text-2xl font-bold mb-8">首發決定：剪刀石頭布！</h2>
            <div class="flex gap-4">
                <button onclick="playRPS('rock')" class="bg-slate-700 p-6 rounded-2xl text-4xl hover:bg-emerald-600 transition-colors">✊</button>
                <button onclick="playRPS('paper')" class="bg-slate-700 p-6 rounded-2xl text-4xl hover:bg-emerald-600 transition-colors">✋</button>
                <button onclick="playRPS('scissors')" class="bg-slate-700 p-6 rounded-2xl text-4xl hover:bg-emerald-600 transition-colors">✌️</button>
            </div>
        </div>
    </div>

    <div id="score-board" class="score-grid"></div>

    <div id="table-wrapper">
        <div id="canvas-container"></div>
        <div id="ai-status" class="absolute top-10 left-1/2 -translate-x-1/2 bg-black/80 px-6 py-2 rounded-full text-xs text-emerald-400 font-mono opacity-0 transition-all border border-emerald-500/30 z-50">AI 分析中...</div>
        <div id="power-meter"><div id="power-fill"></div></div>
    </div>

    <div class="bg-slate-900 p-5 border-t border-slate-800 flex flex-col gap-4">
        <div class="flex justify-between items-center px-2">
            <span id="turn-msg" class="text-sm font-black text-yellow-500 italic">等待猜拳...</span>
            <span class="text-[10px] text-slate-500 font-mono tracking-widest">PHYSICS v14.4</span>
        </div>
        <div class="flex gap-3">
            <button id="undo-btn" class="flex-[1] bg-slate-800 py-4 rounded-2xl font-bold text-xs hover:bg-slate-700 disabled:opacity-30 transition-all">UNDO</button>
            <button id="main-btn" class="flex-[2] bg-emerald-600 py-4 rounded-2xl font-black text-xs uppercase tracking-widest shadow-lg active:scale-95 transition-all">佈置發球</button>
        </div>
    </div>
</div>

<script>
    const { Engine, Render, Runner, Bodies, Composite, Events, Vector, Body } = Matter;

    const engine = Engine.create();
    engine.gravity.y = 0;
    engine.velocityIterations = 80; // 提升碰撞精度
    engine.positionIterations = 80;

    const container = document.getElementById('canvas-container');
    const tableH = Math.min(window.innerHeight * 0.55, 600);
    const tableW = tableH / 2;
    const scale = tableW / 137;
    const ballR = (6.0 * scale) / 2; 
    const pkSize = ballR * 2.8;

    const render = Render.create({
        element: container, engine: engine,
        options: { width: tableW, height: tableH, wireframes: false, background: '#065f46' }
    });

    let balls = [], activeBall = null, gameState = 'CONFIG', turnIdx = 0, lastLoser = -1;
    let teamData = [], history = null, comboCount = 0;
    let aiAimPoint = null, showGuide = true, showPower = true;

    function buildTable() {
        Composite.clear(engine.world);
        const wallOpt = { isStatic: true, restitution: 0.9, friction: 0.1, render: { fillStyle: '#2d4d43' } };
        const th = 200, g = pkSize * 1.2;

        Composite.add(engine.world, [
            Bodies.rectangle(tableW/4, -th/2, tableW/2-g, th, wallOpt),
            Bodies.rectangle(3*tableW/4, -th/2, tableW/2-g, th, wallOpt),
            Bodies.rectangle(tableW/4, tableH+th/2, tableW/2-g, th, wallOpt),
            Bodies.rectangle(3*tableW/4, tableH+th/2, tableW/2-g, th, wallOpt),
            Bodies.rectangle(-th/2, tableH*0.25, th, tableH*0.5-g, wallOpt),
            Bodies.rectangle(-th/2, tableH*0.75, th, tableH*0.5-g, wallOpt),
            Bodies.rectangle(tableW+th/2, tableH*0.25, th, tableH*0.5-g, wallOpt),
            Bodies.rectangle(tableW+th/2, tableH*0.75, th, tableH*0.5-g, wallOpt)
        ]);
        
        const pks = [{x:0,y:0},{x:tableW,y:0},{x:0,y:tableH/2},{x:tableW,y:tableH/2},{x:0,y:tableH},{x:tableW,y:tableH}];
        pks.forEach(p => {
            const h = document.createElement('div');
            h.className = 'pocket-hole';
            h.style.width = h.style.height = (pkSize * 1.8) + 'px';
            h.style.left = (p.x - pkSize * 0.9) + 'px';
            h.style.top = (p.y - pkSize * 0.9) + 'px';
            container.appendChild(h);
        });
    }

    function createBall(x, y, color, label, stroke) {
        const b = Bodies.circle(x, y, ballR, {
            label, restitution: 0.9, friction: 0.05, frictionAir: 0.018,
            render: { fillStyle: color, strokeStyle: stroke, lineWidth: 2 }
        });
        Composite.add(engine.world, b);
        return b;
    }

    // --- 猜拳與規則邏輯 ---
    function playRPS(playerChoice) {
        const choices = ['rock', 'paper', 'scissors'];
        const aiChoice = choices[Math.floor(Math.random() * 3)];
        document.getElementById('rps-ui').classList.add('hidden');
        
        if (playerChoice === aiChoice) {
            alert(`平手 (${playerChoice} vs ${aiChoice})，重來一次！`);
            document.getElementById('rps-ui').classList.remove('hidden');
            return;
        }

        const winMap = { rock: 'scissors', paper: 'rock', scissors: 'paper' };
        turnIdx = (winMap[playerChoice] === aiChoice) ? 0 : 1;
        
        alert(`猜拳結果：你出 ${playerChoice}，AI 出 ${aiChoice}。由 TEAM ${String.fromCharCode(65+turnIdx)} 首發！`);
        startGame();
    }

    function startGame() {
        buildTable();
        // 加分球放在三角區
        createBall(tableW/2, tableH*0.12, '#111', 'BONUS_B', '#fbbf24');
        createBall(tableW/2 - 20, tableH*0.18, '#fff', 'BONUS_W1', '#94a3b8');
        createBall(tableW/2 + 20, tableH*0.18, '#fff', 'BONUS_W2', '#94a3b8');
        
        gameState = 'IDLE';
        updateUI();
        if (turnIdx === 1) aiTurn();
    }

    function updateUI() {
        const sb = document.getElementById('score-board');
        sb.innerHTML = '';
        teamData.forEach((t, i) => {
            sb.innerHTML += `
                <div class="team-box ${turnIdx===i?'active-turn':''}" style="border-left: 6px solid ${i===0?'#f43f5e':'#3b82f6'}">
                    <div class="flex justify-between items-center mb-1">
                        <span class="text-[10px] font-black text-slate-400 uppercase">TEAM ${String.fromCharCode(65+i)}</span>
                        <span class="px-2 py-0.5 bg-black/30 rounded text-[9px] font-mono text-emerald-400">${t.ammo} SHOTS</span>
                    </div>
                    <div class="text-3xl font-black italic tracking-tighter" style="color: ${i===0?'#f43f5e':'#3b82f6'}">${t.score}</div>
                </div>`;
        });
        document.getElementById('turn-msg').innerText = `輪到 TEAM ${String.fromCharCode(65+turnIdx)} 擊球`;
    }

    // --- AI 策略優化（領先時賺分數，優先擊打對手球） ---
    function aiTurn() {
        if (gameState !== 'IDLE') return;
        spawnNew();
        const status = document.getElementById('ai-status');
        status.style.opacity = 1;
        status.innerText = "AI 正在評估最優得分點...";

        setTimeout(() => {
            const playerIdx = 0, aiIdx = 1;
            let target = null, power = 0.01, strategy = "";

            const otherBalls = balls.filter(b => b !== activeBall);
            
            // 優先找靠近洞口的加分球
            const easyBonus = otherBalls.find(b => b.label.includes('BONUS') && b.position.y < tableH * 0.3);
            
            // 如果 AI 領先，或者對手球位置很好打，則擊打對手球來賺分 (25分)
            const playerBalls = otherBalls.filter(b => b.label === `TEAM_${playerIdx}`);
            
            if (easyBonus) {
                target = easyBonus;
                strategy = "清理加分球賺分";
            } else if (playerBalls.length > 0) {
                target = playerBalls[0];
                strategy = "擊飛對手球賺分";
            } else {
                target = { position: { x: tableW/2, y: 50 } };
                strategy = "佈局進攻";
            }

            const dist = Vector.magnitude(Vector.sub(target.position, activeBall.position));
            power = Math.min(0.02, 0.006 + (dist / tableH) * 0.015);
            aiAimPoint = target.position;

            setTimeout(() => {
                const angle = Vector.angle(activeBall.position, target.position);
                launch(Vector.mult({ x: Math.cos(angle), y: Math.sin(angle) }, power));
                status.style.opacity = 0;
                aiAimPoint = null;
            }, 1000);
        }, 1200);
    }

    function launch(f) {
        // 子步進運算防穿透
        for(let i=0; i<5; i++) {
            Engine.update(engine, 1000/60/5);
        }
        Body.applyForce(activeBall, activeBall.position, f);
        gameState = 'MOVING';
        checkStop();
    }

    function checkStop() {
        const timer = setInterval(() => {
            const moving = balls.some(b => b.speed > 0.1);
            if (!moving) {
                clearInterval(timer);
                processTurn();
            }
        }, 600);
    }

    function processTurn() {
        if (teamData.every(t => t.ammo <= 0)) {
            let bestY = Infinity, roundWinner = -1;
            balls.forEach(b => { if(b.position.y < bestY && b.label.includes('TEAM_')) { bestY = b.position.y; roundWinner = parseInt(b.label.split('_')[1]); }});
            if (roundWinner >= 0) {
                teamData[roundWinner].score += 75;
                lastLoser = (roundWinner === 0) ? 1 : 0;
            }
            updateUI();
            alert("本局結束！依照輸家後攻原則進行下一輪。");
            turnIdx = lastLoser; // 輸家後攻
            return;
        }
        
        turnIdx = (turnIdx + 1) % 2;
        if (teamData[turnIdx].ammo <= 0) turnIdx = (turnIdx + 1) % 2;
        
        gameState = 'IDLE';
        updateUI();
        if (turnIdx === 1) aiTurn();
    }

    // 碰撞消失與得分
    Events.on(engine, 'afterUpdate', () => {
        balls.forEach((b, idx) => {
            if (b.position.x < -10 || b.position.x > tableW + 10 || b.position.y < -10 || b.position.y > tableH + 10) {
                const striker = teamData[turnIdx === 0 ? 1 : 0]; // 剛擊球的人
                if (b.label.includes('TEAM_') && parseInt(b.label.split('_')[1]) !== (turnIdx === 0 ? 1 : 0)) striker.score += 25;
                else if (b.label.includes('BONUS')) { comboCount++; striker.score += (comboCount === 1 ? 50 : 100); }
                Composite.remove(engine.world, b);
                balls.splice(idx, 1);
                updateUI();
            }
        });
    });

    // --- 擊球力道與瞄準線渲染 ---
    let dragStart = null, currentPt = null;
    container.addEventListener('touchstart', (e) => {
        if (turnIdx !== 0 || gameState !== 'READY') return;
        const rect = container.getBoundingClientRect();
        dragStart = { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
        if(showPower) document.getElementById('power-meter').style.display = 'block';
    });

    container.addEventListener('touchmove', (e) => {
        const rect = container.getBoundingClientRect();
        currentPt = { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
        
        if (gameState === 'SPAWNED' && currentPt.y > tableH * 0.7) Body.setPosition(activeBall, currentPt);
        
        if (dragStart && currentPt && showPower) {
            const dist = Vector.magnitude(Vector.sub(dragStart, currentPt));
            const powerPct = Math.min(100, (dist / 150) * 100);
            document.getElementById('power-fill').style.width = powerPct + '%';
        }
        e.preventDefault();
    }, { passive: false });

    container.addEventListener('touchend', () => {
        if (turnIdx === 0 && gameState === 'READY' && dragStart && currentPt) {
            const f = Vector.mult(Vector.sub(dragStart, currentPt), 0.0001);
            launch(f);
            teamData[0].ammo--;
        }
        document.getElementById('power-meter').style.display = 'none';
        dragStart = currentPt = null;
    });

    Events.on(render, 'afterRender', () => {
        const ctx = render.context;
        // 渲染加分區域（三角線）
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.beginPath();
        ctx.moveTo(tableW/2, 0); ctx.lineTo(0, tableH*0.25); ctx.lineTo(tableW, tableH*0.25); ctx.closePath();
        ctx.stroke();

        // 瞄準線
        if (showGuide) {
            if (aiAimPoint && turnIdx === 1) {
                ctx.strokeStyle = 'rgba(244, 63, 94, 0.5)';
                ctx.setLineDash([5, 5]);
                ctx.beginPath(); ctx.moveTo(activeBall.position.x, activeBall.position.y); ctx.lineTo(aiAimPoint.x, aiAimPoint.y); ctx.stroke();
            }
            if (gameState === 'READY' && dragStart && currentPt) {
                const dx = dragStart.x - currentPt.x, dy = dragStart.y - currentPt.y;
                ctx.strokeStyle = '#10b981'; ctx.setLineDash([5, 5]);
                ctx.beginPath(); ctx.moveTo(activeBall.position.x, activeBall.position.y);
                ctx.lineTo(activeBall.position.x + dx*8, activeBall.position.y + dy*8); ctx.stroke();
            }
        }
    });

    // 介面交互
    document.getElementById('start-btn').addEventListener('click', () => {
        const a = parseInt(document.getElementById('ball-qty').value);
        showGuide = document.getElementById('show-guideline').checked;
        showPower = document.getElementById('show-power').checked;
        teamData = [{score:0, ammo:a}, {score:0, ammo:a}];
        document.getElementById('config-ui').classList.add('hidden');
        document.getElementById('rps-ui').classList.remove('hidden');
    });

    document.getElementById('main-btn').addEventListener('click', () => {
        if (gameState === 'IDLE') spawnNew();
        else if (gameState === 'SPAWNED') { gameState = 'READY'; document.getElementById('main-btn').innerText = "拖拽擊球"; }
    });

    function spawnNew() {
        activeBall = createBall(tableW/2, tableH * 0.85, turnIdx===0?'#f43f5e':'#3b82f6', `TEAM_${turnIdx}`, '#fff');
        balls.push(activeBall);
        gameState = 'SPAWNED';
        document.getElementById('main-btn').innerText = "鎖定位置";
    }

    Render.run(render); Runner.run(Runner.create(), engine);
</script>
</body>
</html>

